# WebSocket API Specification: Typing Tournament

This document outlines the WebSocket event structure, authentication model, and data payloads for the Typing Tournament application. It is intended for developers working on both the frontend (React) and backend (Rust) components.

## 1. Core Principles

### 1.1. Communication Model
The API primarily uses a **request-response** model for client-initiated actions, where events like `eventName` expect a corresponding `eventName:success` or `eventName:failure` from the server. Additionally, the server can proactively push updates to clients.

### 1.2. Identity & Tournament Association (Handshake)

Clients connect to a specific tournament by including the tournament identifier (`id`) as a query parameter in the WebSocket connection URL. The server uses this `id` to associate the client's socket instance with the tournament-specific room.

**Key Concepts:**

*   **`AuthSchema` (Server-Side Context):** On the backend, an `AuthSchema` (containing an `Option<UserSchema>`) is established for each connection, typically via middleware. This provides context about the user's authenticated state.
*   **`TypistSchema` (The Participant):** Represents the entity participating in the tournament. Each participant, whether a logged-in user or an anonymous guest, is represented by a `TypistSchema`. This schema includes a unique `typistId` and optional `TypistUser` details.
*   **`typistId`:** The primary identifier for a participant within the tournament ecosystem.
    *   **For Authenticated Users:** If `AuthSchema.user` is `Some(user_data)`, the `typistId` assigned to their `TypistSchema` will be derived from `user_data.id`. `A-Za-z0-9` and `length = 12`
    *   **For Unauthenticated Users:** A unique `typistId` is generated by the server. `UUIDv4`

**Joining a Tournament:**

1.  **Authenticated User (Default Participation):**
    *   The client connects to `namespaceUrl?id=<tournamentId>`.
    *   The server, using the `AuthSchema.user.id`, assigns this as the `typistId`. The `TypistSchema` will include user details.

2.  **Authenticated User (Anonymous Participation):**
    *   The client connects to `namespaceUrl?id=<tournamentId>&anonymous=true`.
    *   The server, using `AuthSchema.user.id`, assigns this as the `typistId`. However, due to the `anonymous=true` flag, the `TypistSchema.user` field will be `null` for this tournament session, making them appear anonymous within the tournament room.

3.  **Unauthenticated User (Always Anonymous):**
    *   The client connects to `namespaceUrl?id=<tournamentId>`.
    *   If the client includes a valid `X-Typist-Unique` header (see [Section 2: Authentication & Anonymous Participation](#2-authentication--anonymous-participation)), the server will attempt to use the `typistId` it contains.
    *   If no such valid header is found, the server generates a new unique `typistId`. This new `typistId` is then sent back to the client in the `JoinSuccessPayload` alongside a unique value `noAuthUnique` from which `typistId` can be derived. The client should attach the value of `noAuthUnique` to subsequent requests as `X-Typist-Unique` header to maintain session continuity.
    *   The `TypistSchema.user` field will be `null`.

4.  **Spectator:**
    *   To join as a **spectator**, an additional `spectator=true` query parameter should be included: `namespaceUrl?id=<tournamentId>&spectator=true`.
    *   Spectator sockets, while in the same room for broadcasts, will not have server-side listeners registered for participant-specific events (e.g., `type`, `me`).
    *   Their `TypistSchema` data will be absent from the `JoinSuccessPayload.participants`.

**Connection Confirmation:**
*   Successful association is confirmed by a `join:success` event. The payload includes the client's assigned `typistId`.
*   Failure results in a `join:failure` event.

_Client-side example (authenticated participant):_
```javascript
const socket = io(namespaceUrl, {
  transports: ["polling", "websocket", "webtransport"],
  query: { id: tournamentId },
  extraHeaders,
});
```

_Client-side example (authenticated participant, joining anonymously):_
```javascript
const socket = io(namespaceUrl, {
  query: { id: tournamentId, anonymous: "true" },
  extraHeaders,
});
```

_Client-side example (unauthenticated participant):_
```javascript
const socket = io(namespaceUrl, {
  query: { id: tournamentId },
  extraHeaders: { ...extraHeaders, ...(noAuthUnique ? { "X-Typist-Unique": noAuthUnique }: {}) }
});
```

_Client-side example (spectator):_
```javascript
const socket = io(namespaceUrl, {
  query: { id: tournamentId, spectator: "true" },
  extraHeaders,
});
```

### 1.3. WebSocket Transport Configuration
Transport order: `["polling", "websocket", "webtransport"]`.

### 1.4. Error Handling
All payloads for `:failure` events are of type `WsFailurePayload`, containing an error code and message.

---

## 2. Authentication & Anonymous Participation

The system supports both authenticated (logged-in) users and unauthenticated (guest) typists.

### 2.1. Authenticated Users
*   Identified server-side via `AuthSchema`.
*   Their `UserSchema.id` is used to derive their `typistId` in tournaments.
*   Can choose to participate anonymously in a specific tournament using the `anonymous=true` query parameter during WebSocket handshake. This sets `TypistSchema.user` to `null` for that tournament session, masking their identity within the room, but their `typistId` remains their `UserSchema.id`.

### 2.2. Unauthenticated Typists
*   These are users who are not logged in.
*   To maintain session continuity across page loads or for features like the tournament list page (to show if they are `participating`), a `typistId` is managed via a JWT:
    1.  **Initial Join:** If an unauthenticated user joins a tournament without an existing `X-Typist-Unique`, the server generates a new `typistId`.
    2.  **Token Issuance:** This `typistId` is securely encoded into a JWT by the server and should be communicated back to the client (e.g., in the `join:success` payload or a dedicated event/header).
    3.  **Client Storage:** The client should store this JWT (e.g., in `localStorage`).
    4.  **Subsequent Requests:** For all subsequent WebSocket connections and relevant HTTP API calls (like fetching the tournament list), the client must include this JWT in an `X-Typist-Unique` custom header.
    5.  **Server Reconciliation:** The server decodes the JWT from the `X-Typist-Unique` header to retrieve the `typistId`, allowing it to recognize the returning anonymous typist.
*   The `TypistSchema.user` for anonymous typists is always `null`.

### 2.3. Determining Participation for Tournament Lists
For HTTP endpoints that list tournaments (e.g., `/tournaments`), the `participating: boolean` flag for each tournament is determined as follows:
*   **Authenticated Users:** The server uses the `AuthSchema.user.id` (which is their `typistId`) to check against active tournament participants in the `TournamentRegistry`.
*   **Unauthenticated Users:** The server attempts to decode a `typistId` from the `X-Typist-Unique` header. If a valid `typistId` is found, it's used to check participation. If no token or an invalid token is provided, `participating` will be `false`.

---

## 3. Client-to-Server Events

Events emitted by the client to the server.

| Event   | Description                                                                  | Payload            | Expected Server Response(s) for Participants                | Notes for Spectators & Non-Typing Anonymous Users         |
| ------- | ---------------------------------------------------------------------------- | ------------------ | ----------------------------------------------------------- | --------------------------------------------------------- |
| `me`    | Request the client's own typing session data.                                | `{}`               | `me:success`, `me:failure`                                  | No server-side listener. No application-level response.   |
| `all`   | Request typing session data for all participants in the tournament.          | `{}`               | `all:success`, `all:failure`                                | Permitted. Server listens and responds.                   |
| `leave` | Notify the server of the client's intent to gracefully leave the tournament. | `{}`               | `leave:success`, `leave:failure`                            | Permitted. Server listens and responds.                   |
| `type`  | Notify the server that the client has typed a character.                     | `TypeEventPayload` | `type:failure` or eventually triggers an `update:me` event. | No server-side listener. No application-level response.   |
| `data`  | Request comprehensive information about the current tournament.              | `{}`               | `data:success`, `data:failure`                              | Permitted. Server listens and responds.                   |
| `check` | Request a status overview of the tournament.                                 | `{}`               | `check:success`, `check:failure`                            | Permitted. Server listens and responds.                   |

---

## 4. Server-to-Client Events

Events emitted by the server to client(s).

### 4.1. Responses to Client Requests

Sent to a specific client in direct response to their requests (if a server-side listener for the event and client type exists).

| Event           | Description                                                            | Payload Type          |
| --------------- | ---------------------------------------------------------------------- | --------------------- |
| `join:success`  | Confirms successful tournament association and provides initial data.  | `JoinSuccessPayload`  |
| `join:failure`  | Indicates failure to associate with the tournament.                    | `WsFailurePayload`    |
| `me:success`    | Returns the client's typing session data (Participants only).          | `MeSuccessPayload`    |
| `me:failure`    | Indicates an error fetching client's session data (Participants only). | `WsFailurePayload`    |
| `all:success`   | Returns typing session data for all participants.                      | `AllSuccessPayload`   |
| `all:failure`   | Indicates an error fetching all participants' data.                    | `WsFailurePayload`    |
| `leave:success` | Confirms successful departure from the tournament.                     | `LeaveSuccessPayload` |
| `leave:failure` | Indicates an error during the leave process.                           | `WsFailurePayload`    |
| `type:failure`  | Indicates an error processing the `type` event (Participants only).    | `WsFailurePayload`    |
| `data:success`  | Returns comprehensive tournament information.                          | `DataSuccessPayload`  |
| `data:failure`  | Indicates an error fetching tournament information                     | `WsFailurePayload`    |
| `check:success` | Returns the current status of the tournament.                          | `CheckSuccessPayload` |
| `check:failure` | Indicates an error fetching tournament status.                         | `WsFailurePayload`    |

### 4.2. Proactive Server Updates (Partial Data)

Pushed by the server. Payloads represent partial data from their corresponding `*:success` payloads, containing only changed fields.

#### 4.2.1. Update to Current Client (Participants Only)

These events are sent to the **participant** client whose data has changed. Spectators and non-typing anonymous users do not receive this event.

| Event       | Description                                                        | Payload Type      |
| ----------- | ------------------------------------------------------------------ | ----------------- |
| `update:me` | Server-initiated partial update of the participant's session data. | `UpdateMePayload` |

#### 4.2.2. Update to All Clients in Room (Including Spectators)

Sent to all clients (participants and spectators) within the same tournament room.

| Event         | Description                                                    | Payload Type        |
| ------------- | -------------------------------------------------------------- | ------------------- |
| `update:all`  | Server-initiated partial update of participants' session data. | `UpdateAllPayload`  |
| `update:data` | Server-initiated partial update of overall tournament data.    | `UpdateDataPayload` |

### 4.3. Broadcast Notifications (Full Data) (Including Spectators)

Broadcast to all clients (participants and spectators) in the tournament room. These carry full data payloads.

| Event           | Description                                                    | Payload Type          |
| --------------- | -------------------------------------------------------------- | --------------------- |
| `member:joined` | Notifies that a new **participant** has joined the tournament. | `MemberJoinedPayload` |
| `member:left`   | Notifies that a **participant** has left the tournament.       | `MemberLeftPayload`   |

---

## 5. Payload Type Definitions (TypeScript)

These define the structure of data exchanged for various events.

### 5.1. Core Identity & Data Types

```typescript
// Represents an authenticated user's core data
export type UserSchema = {
  id: string; // Unique user identifier
  username: string;
  email: string; // Included for completeness, may not always be used in typist contexts
  // avatarUrl?: string; // Future improvement
};

// Represents a user's details for display within a tournament (if not anonymous)
export type TypistUser = {
  id: string;   // Corresponds to UserSchema.id
  name: string; // Typically UserSchema.username
  // avatarUrl?: string; // Future improvement
};

// Represents a participant (typist) in a tournament
export type TypistSchema = {
  id: string;                // The unique typistId for this session/participant
  user: TypistUser | null;   // User details if authenticated and not explicitly anonymous; null otherwise
};

export type TextOptions = {
  uppercase: boolean;
  lowercase: boolean;
  numbers: boolean;
  symbols: boolean;
  meaningful: boolean;
};

export type TournamentData = {
  id: string;
  title: string;
  createdAt: string;
  createdBy: string; // User ID of the creator
  scheduledFor: string;
  description: string;
  textOptions: TextOptions;
  privacy: "public" | "private"; // Example privacy options
  startedAt: string | null;
  endedAt: string | null;
  text: string | null; // The actual text for typing
};

export type ParticipantData = {
  typist: TypistSchema; // Information about the typist
  currentPosition: number;
  correctPosition: number;
  totalKeystrokes: number;
  currentSpeed: number;     // Words per minute (WPM)
  currentAccuracy: number;  // Percentage
  startedAt: string | null; // Timestamp when this participant started typing
  endedAt: string | null;   // Timestamp when this participant finished typing
};
```

### 5.2. Common Event Payloads

```typescript
export type WsFailurePayload = {
  code: number;
  message: string;
};

// For client-to-server events that expect a success/failure response
export type PollableEvent = "me" | "all" | "data" | "check" | "leave";

export type TypeEventPayload = {
  character: string;
  // cursor?: number; // Future improvement: client's current cursor position
};
```

### 5.3. Specific Event Payloads

#### `JoinSuccessPayload`
```typescript
export type JoinSuccessPayload = {
  data: TournamentData;       // Initial tournament data
  typistId: string;           // The typistId assigned to this client for this session
  participants: ParticipantData[]; // List of current participants
  // anonymousTypistToken?: string; // Optional: If server issues/refreshes JWT for anonymous typist
};
```

#### `MeSuccessPayload` (for `me:success`)
```typescript
export type MeSuccessPayload = ParticipantData;
```

#### `UpdateMePayload` (for `update:me`)
`typistId` is implicit (the recipient of the message).
```typescript
export type UpdateMePayload = {
  updates: Partial<Omit<ParticipantData, "typist">>; // typist info generally doesn't change mid-session
};
```

#### `AllSuccessPayload` (for `all:success`)
```typescript
export type AllSuccessPayload = ParticipantData[];
```

#### `UpdateAllPayload` (for `update:all`)
```typescript
type PartialParticipantDataForUpdate = {
  typistId: string; // Identifies which participant's data to update
} & { updates: Partial<Omit<ParticipantData, "typist">> };

export type UpdateAllPayload = {
  updates: PartialParticipantDataForUpdate[];
};
```

#### `DataSuccessPayload` (for `data:success`)
```typescript
export type DataSuccessPayload = TournamentData;
```

#### `UpdateDataPayload` (for `update:data`)
Partial `TournamentData`. `id`, `createdAt`, `createdBy` are typically immutable post-creation.
```typescript
export type UpdateDataPayload = Partial<
  Omit<TournamentData, "id" | "createdAt" | "createdBy">
>;
```

#### `CheckSuccessPayload` (for `check:success`)
```typescript
export type CheckSuccessPayload = {
  status: "upcoming" | "started" | "ended";
};
```

#### `MemberJoinedPayload` (for `member:joined`)
```typescript
export type MemberJoinedPayload = {
  participant: ParticipantData; // Full data of the new participant
};
```

#### `MemberLeftPayload` (for `member:left`)
```typescript
export type MemberLeftPayload = {
  typistId: string; // ID of the participant who left
};
```

#### `LeaveSuccessPayload` (for `leave:success`)
```typescript
export type LeaveSuccessPayload = {
  message: string; // e.g., "Successfully left the tournament."
};
```

---

## 6. Server-Side Implementation Notes

### 6.1. Typist and User Data Structures (Rust Example Context)

The following Rust structs illustrate the conceptual data model on the server.

```rust
Represents the authenticated user context, available in request extensions.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthSchema {
    pub user: Option<UserSchema>,
}

Core user information.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct UserSchema {
    pub id: String,
    pub username: String,
    pub email: String,
}

Slimmed-down user representation for typist display.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TypistUser {
    pub id: String, // Corresponds to UserSchema.id
    pub name: String,
}

Represents a typist in a tournament.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TypistSchema {
    pub id: String, // The typistId for this session.
                   // For authenticated users, this is their UserSchema.id.
                   // For anonymous users, this is a generated ID.
    pub user: Option<TypistUser>, // Null if anonymous or authenticated user chose anonymity.
}
```

### 6.2. Tournament Management Logic

```
// ========================================================================
// SECTION PLACEHOLDER: Server-Side Tournament Management
// ========================================================================
// This section should detail:
//   - How the `TournamentRegistry` and `TypingSessionRegistry` are structured and used.
//   - Logic for associating `typistId` with sockets and tournament rooms.
//   - Handling of `AuthSchema` to determine `typistId` for authenticated users.
//   - Generation, issuance, and validation of JWTs for anonymous `typistId`.
//   - How the `anonymous=true` query parameter influences `TypistSchema` creation.
//   - Management of participant lists and state within each tournament instance.
//   - State persistence strategies, if any.
//   - Specifics of `AppState` and its role.
//
// Example considerations:
//   - Mapping `socket.id` to `typistId` and `tournamentId`.
//   - Broadcasting events to specific rooms.
//   - Cleaning up typist sessions on disconnect or `leave` events.
//   - Thread-safety for shared registries.
// ========================================================================
```

### 6.3. Dynamic Payload Construction
The server may use `serde_json::json!` for dynamic construction of JSON response payloads, particularly for structures not requiring predefined Rust structs and for partial updates.

```rust
// use serde_json::json;
//
// let payload = json!({
//     "typistId": "typist_id_example",
//     "message": "Successfully joined the tournament."
// });
// socket.emit("join:success", payload).ok();
```

---

## 7. Client-Side State Management & Event Handling

### 7.1. Recommended Event Handling (`fire` function)

A robust pattern for handling client-initiated events expecting a response:

```typescript
// (The `fire` function as provided in the original document is suitable)
// async function fire(eventName: PollableEvent, payload: unknown = {}) { ... }
// Usage Example:
// try {
//   const result = await socketInstance.fire("eventName", payload);
//   if (result.success) { console.log("Data:", result.data); }
//   else { console.warn("Error:", result.error); }
// } catch (error) { console.error("Request failed:", error); }
```

### 7.2. Core State Variables

1.  **`participants`: `Record<string, ParticipantData>`**
    *   Key: `participant.typist.id` (the `typistId`).
    *   Populated/updated by: `JoinSuccessPayload.participants`, `AllSuccessPayload`, `update:all`, `member:joined`, `member:left`.
2.  **`tournamentData`: `TournamentData | null`**
    *   Populated/updated by: `JoinSuccessPayload.data`, `DataSuccessPayload`, `update:data`.
3.  **`myTypistData`: `ParticipantData | null`** (For the current client, if participating)
    *   Populated when `JoinSuccessPayload.typistId` matches an entry in `participants`, or from `MeSuccessPayload`.
    *   Updated by `update:me`.
    *   `null` for spectators or if not yet joined.
4.  **`myTypistId`: `string | null`**
    *   Set from `JoinSuccessPayload.typistId`.
5.  **`isSpectator`: `boolean`**
    *   Determined client-side after `join:success`.
    *   **True** if:
        *   Client joined with `spectator=true` query.
        *   OR `JoinSuccessPayload.typistId` is not found as a `typist.id` within `JoinSuccessPayload.participants` (and client didn't intend to be a participant).
    *   **False** otherwise.
6.  **`anonymousTypistToken`: `string | null`**
    *   Stored (e.g., in `localStorage`) and managed by the client.
    *   Received from server (e.g., in `JoinSuccessPayload` or a specific auth event) if the user is anonymous and a new token is issued/refreshed.
    *   Sent in `X-Typist-Unique` header for WebSocket handshakes and relevant HTTP requests.

### 7.3. Additional State Considerations
*   `TournamentData.text` and `TournamentData.startedAt` will often be updated simultaneously via an `update:data` event when a tournament starts.
*   The server might batch multiple `type` events from a participant into a single `update:me` event.

### 7.4. WebSocket Implementation Notes
*   Abstract WebSocket logic into a reusable class or service.
*   Use a single WebSocket connection per client instance.
*   Implement robust reconnect logic. Upon reconnection and successful `join:success`, refresh client-side state to ensure consistency.
*   All **pollable events** can be retried by the client.

### 7.5. Client-Side Implementation Strategy
```
// ========================================================================
// SECTION PLACEHOLDER: Client-Side Implementation Strategy (React/Frontend)
// ========================================================================
// This section should detail:
//   - State management library choice (e.g., Zustand, Redux, Context API) and structure.
//   - WebSocket service/hook implementation.
//   - Handling of `anonymousTypistToken` (storage, retrieval, header injection).
//   - Logic for determining `isSpectator` and `isAnonymousParticipant`.
//   - UI updates based on received WebSocket events.
//   - Component structure for displaying tournament info, participant lists, typing area, etc.
//   - Conditional rendering for participants vs. spectators.
//   - Forms for joining tournaments and handling different join modes.
//
// Example considerations:
//   - React Context for WebSocket instance and core state.
//   - Custom hooks for interacting with the socket (`useSocketEmitter`, `useSocketListener`).
//   - Axios interceptors or a wrapper function to add `X-Typist-Unique` to HTTP requests.
//   - Debouncing or throttling for sending `type` events if necessary.
// ========================================================================
```

---

## 8. Spectator Mode

Clients can join tournaments as non-participating spectators.

### 8.1. Joining as a Spectator
*   Include `spectator=true` in the WebSocket connection URL query:
    `const socket = io(namespaceUrl, { query: { id: tournamentId, spectator: "true" } });`

### 8.2. Server-Side Handling of Spectators
*   Added to the same WebSocket room for broadcasts.
*   No server-side listeners for participant-specific events like `type` or `me`.
*   Will not receive `update:me` events.
*   Will receive `update:all`, `update:data`, `member:joined`, `member:left`.
*   Can interact with general events like `all`, `data`, `check`, `leave`.
*   If a client joins *only* as a spectator, their `TypistSchema` data will not be part of the `JoinSuccessPayload.participants` list (or they won't have a `typistId` that corresponds to a participant entry).

### 8.3. Client-Side Guidance for Spectators
*   Determine spectator status (see [Section 7.2. Core State Variables](#72-core-state-variables)).
*   Disable UI elements/event emissions not applicable to spectators (e.g., typing input).
*   Consider a distinct `SpectatorViewTypingArea` that mirrors participant UI without interaction.

---

## 9. Error Codes

All `:failure` events return a `WsFailurePayload { code: number; message: string; }`.

### 1xxx: Connection & Handshake Errors
| Code | Event(s)       | Default Message Suggestion                     | Notes                                                       |
| ---- | -------------- | ---------------------------------------------- | ----------------------------------------------------------- |
| 1001 | `join:failure` | "Tournament ID missing in handshake query."    | `id` query param not provided.                              |
| 1002 | `join:failure` | "Invalid Tournament ID format."                |                                                             |
| 1003 | `join:failure` | "Tournament not found."                        |                                                             |
| 1004 | `join:failure` | "Maximum participants reached."                |                                                             |
| 1005 | `join:failure` | "Already connected to this tournament."        | If single session per `typistId` is enforced.             |
| 1006 | `join:failure` | "Access denied to private tournament."         |                                                             |
| 1007 | `join:failure` | "Spectator mode parameter invalid."            |                                                             |
| 1008 | `join:failure` | "Anonymous mode parameter invalid."            | e.g., if `anonymous` param has unexpected value.            |
| 1009 | `join:failure` | "Invalid or expired typist token."             | Problem with `X-Typist-Unique` for anonymous typist.       |
| 1010 | `join:failure` | "Authentication context error."                | Server-side issue establishing `AuthSchema`.                |

### 2xxx: Client Request & Validation Errors
| Code | Event(s)       | Default Message Suggestion                      | Notes                                  |
| ---- | -------------- | ----------------------------------------------- | -------------------------------------- |
| 2001 | _Any_          | "Invalid event name."                           | Server received an unrecognized event. |
| 2002 | _Any_          | "Malformed request payload."                    | e.g., Invalid JSON.                    |
| 2101 | `type:failure` | "Invalid payload: 'character' missing/invalid." | `TypeEventPayload` validation failed.  |
| 2201 | `type:failure` | "Typing not allowed: Tournament not started."   |                                        |
| 2202 | `type:failure` | "Typing not allowed: Tournament ended."         |                                        |
| 2203 | `type:failure` | "Typing not allowed: You have finished."        |                                        |
| 2204 | `type:failure` | "Typing not allowed: Spectator mode."           |                                        |
| 2210 | _Most C2S_     | "Not joined to a tournament."                   | Action requires being in a tournament. |

### 3xxx: Resource & State Errors
| Code | Event(s)                                  | Default Message Suggestion         | Notes                                      |
| ---- | ----------------------------------------- | ---------------------------------- | ------------------------------------------ |
| 3001 | `data:failure`                            | "Tournament data unavailable."     | Error fetching overall tournament details. |
| 3101 | `me:failure` (Participant), `all:failure` | "Participant data unavailable."    | Error fetching participant details.        |
| 3102 | `leave:failure`                           | "Failed to process leave request." |                                            |

### 4xxx: Server-Side Operational Errors
| Code | Event(s) | Default Message Suggestion       | Notes                          |
| ---- | -------- | -------------------------------- | ------------------------------ |
| 4000 | _Any_    | "Internal server error."         | Generic server-side issue.     |
| 4001 | _Any_    | "Operation timed out on server." |                                |
| 4101 | _Any_    | "Database error."                | Problem with data persistence. |

_(This list is not exhaustive and should be expanded as specific error cases are identified.)_

---

## 10. Future Improvements

*   **Cursor Position:** Add a `cursor` field to `type` event payloads and server-side resolution logic for inconsistencies.
*   **Spectator Tracking:** Enhance server-side logic to more formally track spectator `TypistSchema` if features like a visible spectator list are desired. This might involve `spectator:joined`, `spectator:left` events, distinct from `member:` events.
*   **User Avatars:** Add an `avatarUrl` or similar attribute to `UserSchema` and `TypistUser` for richer display.
*   **Capacity Limits:** Define and enforce specific tournament capacity limits for participants and (optionally) spectators.
*   **Typing Analytics:** Develop an analytics API and integrate logic to feed it data (e.g., on each `type` event for authenticated users) to analyze typing patterns, weaknesses, and strengths.
*   **Typing Algorithm Customization:** Introduce a `TypingAlgorithm` trait or enum, selectable during tournament creation, to allow different scoring or processing logic for typing events.
*   **Secure typistIds':** Define a secure mechanism for deriving `typistId` from `userId` that retains the character set and length of `userId`: `A-Za-z0-9` and `length = 12`
---